"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _yogaLayoutPrebuilt = _interopRequireDefault(require("yoga-layout-prebuilt"));

var _output = _interopRequireDefault(require("./output"));

var _dom = require("./dom");

var _buildLayout = _interopRequireDefault(require("./build-layout"));

var _renderNodeToOutput = _interopRequireDefault(require("./render-node-to-output"));

var _measureText = _interopRequireDefault(require("./measure-text"));

var _wrapText = _interopRequireDefault(require("./wrap-text"));

var _getMaxWidth = _interopRequireDefault(require("./get-max-width"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Since we need to know the width of text container to wrap text, we have to calculate layout twice
// This function is executed after first layout calculation to reassign width and height of text nodes
const calculateWrappedText = node => {
  if (node.textContent && typeof node.parentNode.style.textWrap === 'string') {
    const {
      yogaNode
    } = node;
    const parentYogaNode = node.parentNode.yogaNode;
    const maxWidth = (0, _getMaxWidth.default)(parentYogaNode);
    const currentWidth = yogaNode.getComputedWidth();

    if (currentWidth > maxWidth) {
      const {
        textWrap
      } = node.parentNode.style;
      const wrappedText = (0, _wrapText.default)(node.textContent, maxWidth, {
        textWrap
      });
      const {
        width,
        height
      } = (0, _measureText.default)(wrappedText);
      yogaNode.setWidth(width);
      yogaNode.setHeight(height);
    }

    return;
  }

  if (Array.isArray(node.childNodes) && node.childNodes.length > 0) {
    for (const childNode of node.childNodes) {
      calculateWrappedText(childNode);
    }
  }
}; // Since <Static> components can be placed anywhere in the tree, this helper finds and returns them


const getStaticNodes = element => {
  const staticNodes = [];

  for (const childNode of element.childNodes) {
    if (childNode.unstable__static) {
      staticNodes.push(childNode);
    }

    if (Array.isArray(childNode.childNodes) && childNode.childNodes.length > 0) {
      staticNodes.push(...getStaticNodes(childNode));
    }
  }

  return staticNodes;
}; // Build layout, apply styles, build text output of all nodes and return it


var _default = ({
  terminalWidth
}) => {
  const config = _yogaLayoutPrebuilt.default.Config.create(); // Used to free up memory used by last Yoga node tree


  let lastYogaNode;
  let lastStaticYogaNode;
  return node => {
    if (lastYogaNode) {
      lastYogaNode.freeRecursive();
    }

    if (lastStaticYogaNode) {
      lastStaticYogaNode.freeRecursive();
    }

    const staticElements = getStaticNodes(node);

    if (staticElements.length > 1) {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Warning: There can only be one <Static> component');
      }
    } // <Static> component must be built and rendered separately, so that the layout of the other output is unaffected


    let staticOutput;

    if (staticElements.length === 1) {
      const rootNode = (0, _dom.createNode)('root');
      (0, _dom.appendStaticNode)(rootNode, staticElements[0]);
      const {
        yogaNode: staticYogaNode
      } = (0, _buildLayout.default)(rootNode, {
        config,
        terminalWidth,
        skipStaticElements: false
      });
      staticYogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR);
      calculateWrappedText(rootNode);
      staticYogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR); // Save current Yoga node tree to free up memory later

      lastStaticYogaNode = staticYogaNode;
      staticOutput = new _output.default({
        width: staticYogaNode.getComputedWidth(),
        height: staticYogaNode.getComputedHeight()
      });
      (0, _renderNodeToOutput.default)(rootNode, staticOutput, {
        skipStaticElements: false
      });
    }

    const {
      yogaNode
    } = (0, _buildLayout.default)(node, {
      config,
      terminalWidth,
      skipStaticElements: true
    });
    yogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR);
    calculateWrappedText(node);
    yogaNode.calculateLayout(_yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.UNDEFINED, _yogaLayoutPrebuilt.default.DIRECTION_LTR); // Save current node tree to free up memory later

    lastYogaNode = yogaNode;
    const output = new _output.default({
      width: yogaNode.getComputedWidth(),
      height: yogaNode.getComputedHeight()
    });
    (0, _renderNodeToOutput.default)(node, output, {
      skipStaticElements: true
    });
    return {
      output: output.get(),
      staticOutput: staticOutput ? `${staticOutput.get()}\n` : undefined
    };
  };
};

exports.default = _default;